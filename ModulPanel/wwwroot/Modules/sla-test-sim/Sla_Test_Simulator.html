<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SD-WAN SLA/PBR Simülatörü</title>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>
    <!-- chartjs-plugin-annotation -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.0/dist/chartjs-plugin-annotation.js"></script>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            width: 100%;
            max-width: 1400px;
            gap: 20px;
        }
        .control-panel, .simulation-area {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .control-panel {
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .simulation-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-section {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
        }
        .control-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin-bottom: 3px;
            font-weight: bold;
            font-size: 0.9em;
        }
        input[type="number"], input[type="text"], select {
            width: calc(100% - 12px);
            padding: 5px;
            margin-bottom: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #dc3545;
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }

        #path-list {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 5px;
        }
        .path-config {
            border: 1px dashed #ccc;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            position: relative;
        }
        .path-config .delete-path {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.8em;
            padding: 2px 5px;
        }
        .metric-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }
        .metric-input-group label {
            min-width: 50px; /* Ensure labels align */
            text-align: right;
            margin-right: 5px;
            margin-bottom: 0;
            font-size: 0.8em;
        }
        .metric-input-group input[type="range"] {
            flex-grow: 1;
        }
        .metric-input-group input[type="number"] {
            width: 60px;
            font-size: 0.8em;
            padding: 3px;
            text-align: right;
        }
        .metric-warning {
            color: #ffc107; /* Warning yellow */
            font-weight: bold;
            font-size: 1em; /* Make warning more visible */
            display: inline-block;
            margin-left: 5px;
            line-height: 1; /* Align with input */
            vertical-align: middle;
        }

        /* Simulation Visualization Styles */
        .simulation-status {
             display: flex;
             justify-content: space-between;
             flex-wrap: wrap; /* Allow wrapping on small screens */
             gap: 10px; /* Add gap between items */
             padding: 5px;
             background-color: #e9ecef;
             border-radius: 4px;
             font-size: 0.9em;
             margin-bottom: 10px;
        }
        #progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            height: 10px;
            overflow: hidden; /* Ensure inner bar stays within bounds */
            margin-bottom: 10px;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #28a745;
            transition: width 0.1s linear; /* Smooth progress updates */
            border-radius: 5px;
        }

        .network-diagram {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Push nodes to edges */
            min-height: 150px; /* Ensure minimum height */
            height: auto; /* Allow height to grow with paths */
            position: relative;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 30px 15%; /* More padding top/bottom, less side padding to keep nodes near edges */
            margin-bottom: 15px;
            box-sizing: border-box; /* Include padding in width calculation */
        }
        .node {
            background-color: #007bff;
            color: white;
            padding: 15px 25px;
            border-radius: 50%;
            font-weight: bold;
            z-index: 1;
            text-align: center;
            white-space: nowrap;
        }
        .path-line {
            position: absolute;
            left: 15%; /* Start further from LAN node edge */
            width: 70%; /* Span between adjusted start/end */
            height: 4px;
            background-color: #ccc; /* Default color */
            z-index: 0;
            transition: background-color 0.3s ease, height 0.3s ease, opacity 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center; /* Center path name */
            opacity: 0.8;
            border-radius: 2px;
        }
         .path-line.good {
            background-color: #28a745; /* Green */
         }
        .path-line.bad {
            background-color: #dc3545; /* Red */
        }
         .path-line.active {
            height: 8px;
            opacity: 1;
            z-index: 2; /* Bring active path line above others slightly */
             box-shadow: 0 0 8px rgba(0, 123, 255, 0.7);
         }
        .path-name-label {
            position: absolute; /* Position relative to the line */
            background-color: rgba(255, 255, 255, 0.9); /* Slightly more opaque */
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8em;
            color: #333;
            white-space: nowrap;
            transform: translateY(-15px); /* Position above the line */
             z-index: 3;
             pointer-events: none; /* Prevent label from interfering with line clicks if needed */
             /* Centering logic applied in JS */
        }

         .traffic-dot {
             position: absolute;
             width: 10px;
             height: 10px;
             background-color: #ffc107; /* Yellow */
             border-radius: 50%;
             z-index: 4;
             display: none; /* Hidden by default */
             transform: translateY(-50%); /* Center vertically on the line */
             animation: moveTraffic 1s linear infinite;
         }

         @keyframes moveTraffic {
             from { left: 15%; } /* Start near LAN */
             to   { left: 85%; } /* End near WAN */
         }

        .charts-container {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        .chart-wrapper {
            width: calc(33% - 10px); /* Adjust for gap */
             min-width: 250px; /* Minimum width */
            height: 250px; /* Fixed height for charts */
            position: relative; /* Needed for Chart.js responsiveness */
        }
        #decision-log {
            width: calc(100% - 12px);
            height: 100px;
            font-family: monospace;
            font-size: 0.8em;
            border: 1px solid #ccc;
            padding: 5px;
            overflow-y: scroll;
            background-color: #f8f9fa;
            white-space: pre-wrap; /* Keep formatting */
        }
    </style>
</head>
<body>

    <h1>SD-WAN SLA/PBR Simülatörü</h1>

    <div class="container">
        <div class="control-panel">
            <div class="control-section">
                <h3>Path Yönetimi (<span id="path-count">0</span>/8)</h3>
                <button id="add-path-button">Path Ekle</button>
                <div id="path-list">
                    <!-- Path konfigürasyonları buraya eklenecek -->
                </div>
            </div>

            <div class="control-section">
                <h3>Probe Ayarları</h3>
                <label for="probe-count">Count (Paket Sayısı):</label>
                <input type="number" id="probe-count" value="10" min="1">
                <label for="probe-wait">Wait (Paket Arası Bekleme - sn):</label>
                <input type="number" id="probe-wait" value="1" min="0" step="0.1">
                <label for="probe-interval">Interval (Döngü Sonu Bekleme - sn):</label>
                <input type="number" id="probe-interval" value="5" min="0" step="0.1">
            </div>

            <div class="control-section">
                <h3>Global SLA Kriterleri</h3>
                <label for="sla-delay">Maks Gecikme (ms):</label>
                <input type="number" id="sla-delay" value="150" min="0">
                <label for="sla-jitter">Maks Jitter (ms):</label>
                <input type="number" id="sla-jitter" value="30" min="0">
                <label for="sla-loss">Maks Kayıp (%):</label>
                <input type="number" id="sla-loss" value="1" min="0" max="100" step="0.1">
            </div>

            <div class="control-section">
                <h3>Davranış Ayarları</h3>
                <label for="preemptive-mode">
                    <input type="checkbox" id="preemptive-mode"> Preemptive Mod Aktif
                </label>
                <label for="simulation-speed">Hızlandırma (1x - 10x): <span id="speed-value">1</span>x</label>
                <input type="range" id="simulation-speed" min="1" max="10" value="1" step="0.5">
            </div>

            <div class="control-section">
                <h3>Simülasyon Kontrolleri</h3>
                <button id="start-button">Başlat</button>
                <button id="stop-button" disabled>Durdur</button>
                <button id="reset-button">Sıfırla</button>
            </div>

             <div class="control-section">
                 <h3>Senaryolar</h3>
                 <button id="scenario-good-mpls" class="secondary">İyi MPLS</button>
                 <button id="scenario-bad-mpls" class="secondary">Kötü MPLS</button>
                 <button id="scenario-flapping" class="secondary">Değişken İnternet</button>
             </div>
        </div>

        <div class="simulation-area">
            <div class="simulation-status">
                <span>Durum: <strong id="sim-status">Bekliyor</strong></span>
                <span>Döngü: <strong id="sim-cycle">0</strong></span>
                <span>Faz: <strong id="sim-phase">-</strong></span>
                <span>Ölçüm Adımı: <strong id="sim-measurement-step">-</strong></span>
                <span>Aktif Path: <strong id="sim-active-path">-</strong></span>
            </div>

            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>

            <div class="network-diagram" id="network-diagram">
                <div class="node">LAN</div>
                <!-- Path çizgileri ve etiketleri buraya JS ile eklenecek -->
                <div class="node">WAN</div>
                 <div class="traffic-dot" id="traffic-dot"></div> <!-- Moved dot outside node flow -->
            </div>

             <div class="charts-container">
                <div class="chart-wrapper">
                    <canvas id="delay-chart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <canvas id="jitter-chart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <canvas id="loss-chart"></canvas>
                </div>
            </div>


            <div class="control-section">
                <h3>Karar Logu</h3>
                <div id="decision-log">Simülasyonu başlatın...</div>
            </div>
        </div>
    </div>

    <!-- Path konfigürasyon şablonu -->
    <template id="path-template">
        <div class="path-config" data-path-id="">
            <button class="delete-path danger">X</button>
            <label>İsim:</label>
            <input type="text" class="path-name" value="Path">
            <label>Öncelik (Düşük=Daha İyi):</label>
            <input type="number" class="path-priority" value="100" min="1">

            <div class="metric-input-group">
                <label>Gecikme:</label>
                <input type="range" class="path-instant-delay-slider" min="1" max="500" value="50" title="Anlık Gecikme (ms)">
                <input type="number" class="path-instant-delay-input" min="1" max="500" value="50" title="Anlık Gecikme (ms)">
                <span class="metric-warning delay-warning" title="Anlık değer SLA'yı aşıyor!" style="display: none;">!</span>
            </div>
             <div class="metric-input-group">
                <label>Jitter:</label>
                <input type="range" class="path-instant-jitter-slider" min="0" max="100" value="5" title="Anlık Jitter (ms)">
                <input type="number" class="path-instant-jitter-input" min="0" max="100" value="5" title="Anlık Jitter (ms)">
                 <span class="metric-warning jitter-warning" title="Anlık değer SLA'yı aşıyor!" style="display: none;">!</span>
            </div>
             <div class="metric-input-group">
                <label>Kayıp:</label>
                <input type="range" class="path-instant-loss-slider" min="0" max="100" value="0" step="0.1" title="Anlık Kayıp (%)">
                <input type="number" class="path-instant-loss-input" min="0" max="100" value="0" step="0.1" title="Anlık Kayıp (%)">
                 <span class="metric-warning loss-warning" title="Anlık değer SLA'yı aşıyor!" style="display: none;">!</span>
            </div>
            <small><i>Nihai Ort: Gec: <span class="final-avg-delay">-</span>, Jit: <span class="final-avg-jitter">-</span>, Kay: <span class="final-avg-loss">-</span>%</i></small><br>
            <small><i>Çalışan Ort: Gec: <span class="running-avg-delay">-</span>, Jit: <span class="running-avg-jitter">-</span>, Kay: <span class="running-avg-loss">-</span>%</i></small>
        </div>
    </template>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Element References ---
    const probeCountInput = document.getElementById('probe-count');
    const probeWaitInput = document.getElementById('probe-wait');
    const probeIntervalInput = document.getElementById('probe-interval');
    const slaDelayInput = document.getElementById('sla-delay');
    const slaJitterInput = document.getElementById('sla-jitter');
    const slaLossInput = document.getElementById('sla-loss');
    const preemptiveModeCheckbox = document.getElementById('preemptive-mode');
    const simulationSpeedSlider = document.getElementById('simulation-speed');
    const speedValueSpan = document.getElementById('speed-value');
    const startButton = document.getElementById('start-button');
    const stopButton = document.getElementById('stop-button');
    const resetButton = document.getElementById('reset-button');
    const addPathButton = document.getElementById('add-path-button');
    const pathListDiv = document.getElementById('path-list');
    const pathTemplate = document.getElementById('path-template');
    const pathCountSpan = document.getElementById('path-count');
    const scenarioGoodMplsButton = document.getElementById('scenario-good-mpls');
    const scenarioBadMplsButton = document.getElementById('scenario-bad-mpls');
    const scenarioFlappingButton = document.getElementById('scenario-flapping');

    const simStatusSpan = document.getElementById('sim-status');
    const simCycleSpan = document.getElementById('sim-cycle');
    const simPhaseSpan = document.getElementById('sim-phase');
    const simMeasurementStepSpan = document.getElementById('sim-measurement-step');
    const simActivePathSpan = document.getElementById('sim-active-path');
    const progressBar = document.getElementById('progress-bar');
    const networkDiagramDiv = document.getElementById('network-diagram');
    const decisionLogDiv = document.getElementById('decision-log');
    const trafficDot = document.getElementById('traffic-dot');

    // --- Simulation State ---
    let paths = [];
    let slaCriteria = {};
    let probeConfig = {};
    let simulationState = {
        isRunning: false,
        currentCycle: 0,
        currentPhase: 'IDLE', // IDLE, MEASUREMENT, WAIT
        phaseStartTime: 0,
        currentPacketInCycle: 0,
        simulationSpeedFactor: 1,
        activePathId: null,
        preemptiveMode: false,
        globalTimerId: null,
        cycleDuration: 0,
        measurementPhaseDuration: 0,
        waitPhaseDuration: 0,
    };
    let charts = { delay: null, jitter: null, loss: null };
    let nextPathId = 0;

    // --- Initialization ---
    function initialize() {
        logMessage('Simülatör başlatıldı.');
        resetSimulationState(); // Resets state, adds defaults internally
        updateProbeConfig();
        updateSlaConfig();
        updateBehaviorConfig();
        // Default paths are added inside resetSimulationState now
        setupEventListeners();
        initCharts();
        updateUI(); // Initial UI update including paths from reset
        logMessage('Varsayılan pathler ve ayarlar yüklendi.');
    }

    function resetSimulationState() {
        stopSimulation(); // Clear any running timers
        paths.forEach(path => {
             // Reset measured/calculated values, keep config
             path.samplesDelay = [];
             path.samplesJitter = [];
             path.samplesLoss = [];
             path.currentPacketCount = 0;
             path.runningAvgDelay = null;
             path.runningAvgJitter = null;
             path.runningAvgLoss = null;
             path.finalAvgDelay = null;
             path.finalAvgJitter = null;
             path.finalAvgLoss = null;
             path.isGood = null; // Based on final avg
             path.score = null; // Based on final avg
             // Reset UI display for this path
             if (path.domOutputs) {
                 updatePathMetricWarnings(path.id); // Update warnings based on current SLA
                 updateFinalAverageUIForPath(path);
                 updateRunningAverageUIForPath(path);
             }
        });

        // If called during initialization or full reset, clear UI and internal state
        if (arguments.length === 0 || arguments[0] === true) { // Check if called by reset button/initialization
            pathListDiv.innerHTML = ''; // Clear path config UI
            paths = []; // Clear internal path data
            nextPathId = 0; // Reset ID counter
            addDefaultPaths(); // Add defaults back (includes adding to UI and paths array)
        }


        simulationState = {
            isRunning: false,
            currentCycle: 0,
            currentPhase: 'IDLE',
            phaseStartTime: 0,
            currentPacketInCycle: 0,
            simulationSpeedFactor: parseFloat(simulationSpeedSlider.value),
            activePathId: null,
            preemptiveMode: preemptiveModeCheckbox.checked,
            globalTimerId: null,
             cycleDuration: 0,
             measurementPhaseDuration: 0,
             waitPhaseDuration: 0,
        };
        simActivePathSpan.textContent = '-';
        simMeasurementStepSpan.textContent = '-';
         decisionLogDiv.innerHTML = 'Simülasyon sıfırlandı.<br>';
        clearCharts(); // Also updates chart labels
        updatePathCount();
        updatePathVisuals(); // Redraw diagram lines
        progressBar.style.width = '0%';
        trafficDot.style.display = 'none';
         updateUIStatus(); // Update general status fields
    }

    function addDefaultPaths() {
        // Assumes paths array and UI are already cleared if needed
        addPath("MPLS", 100, 20, 5, 0);
        addPath("Internet", 200, 50, 15, 0.5);
    }

    // --- Configuration Updates ---
    function updateProbeConfig() {
        probeConfig.count = parseInt(probeCountInput.value) || 1;
        probeConfig.wait = parseFloat(probeWaitInput.value) || 0;
        probeConfig.interval = parseFloat(probeIntervalInput.value) || 0;
        calculateDurations();
        // console.log("Probe Config Updated:", probeConfig);
    }

    function updateSlaConfig() {
        slaCriteria.maxDelay = parseFloat(slaDelayInput.value) || Infinity;
        slaCriteria.maxJitter = parseFloat(slaJitterInput.value) || Infinity;
        slaCriteria.maxLoss = parseFloat(slaLossInput.value) || Infinity;
        // Update warnings on instant metrics
        paths.forEach(path => updatePathMetricWarnings(path.id));
        // Update chart annotations/scales
        updateChartSLALines();
        // console.log("SLA Criteria Updated:", slaCriteria);
    }

    function updateBehaviorConfig() {
        simulationState.preemptiveMode = preemptiveModeCheckbox.checked;
        const newSpeed = parseFloat(simulationSpeedSlider.value);
        // If speed changes while running, adjust remaining time for current step
        // This is tricky; simpler approach: affect next step's duration.
        simulationState.simulationSpeedFactor = newSpeed;
        speedValueSpan.textContent = simulationState.simulationSpeedFactor;
        // console.log("Behavior Config Updated:", simulationState.preemptiveMode, simulationState.simulationSpeedFactor);
    }

    function calculateDurations() {
         // Duration calculation based on FR1.2
         // Note: First packet at t=0, so (Count-1) intervals of Wait seconds.
        simulationState.measurementPhaseDuration = probeConfig.count <= 1 ? 0 : (probeConfig.count - 1) * probeConfig.wait;
        simulationState.waitPhaseDuration = probeConfig.interval;
        // Total duration in seconds for one cycle
        simulationState.cycleDuration = simulationState.measurementPhaseDuration + simulationState.waitPhaseDuration;
        // console.log(`Cycle Duration: ${simulationState.cycleDuration}s (Measure: ${simulationState.measurementPhaseDuration}s, Wait: ${simulationState.waitPhaseDuration}s)`);
     }

    // --- Path Management ---
    function addPath(name = "Yeni Path", priority = 100, delay = 50, jitter = 10, loss = 0.1) {
        if (paths.length >= 8) {
            alert("Maksimum path sayısına ulaşıldı (8).");
            return;
        }
        const pathId = nextPathId++;
        const pathElement = pathTemplate.content.cloneNode(true).firstElementChild;
        pathElement.dataset.pathId = pathId;

        // Configure the new path element
        const nameInput = pathElement.querySelector('.path-name');
        const priorityInput = pathElement.querySelector('.path-priority');
        const instantDelaySlider = pathElement.querySelector('.path-instant-delay-slider');
        const instantDelayInput = pathElement.querySelector('.path-instant-delay-input');
        const instantJitterSlider = pathElement.querySelector('.path-instant-jitter-slider');
        const instantJitterInput = pathElement.querySelector('.path-instant-jitter-input');
        const instantLossSlider = pathElement.querySelector('.path-instant-loss-slider');
        const instantLossInput = pathElement.querySelector('.path-instant-loss-input');
        const deleteButton = pathElement.querySelector('.delete-path');

        // Set initial values
        nameInput.value = name;
        priorityInput.value = priority;
        instantDelaySlider.value = delay;
        instantDelayInput.value = delay;
        instantJitterSlider.value = jitter;
        instantJitterInput.value = jitter;
        instantLossSlider.value = loss;
        instantLossInput.value = loss;

         // Path Data Structure
        const newPath = {
            id: pathId,
            name: name,
            priority: parseInt(priority),
            instantDelay: parseFloat(delay),
            instantJitter: parseFloat(jitter),
            instantLoss: parseFloat(loss),
            samplesDelay: [],
            samplesJitter: [],
            samplesLoss: [],
            currentPacketCount: 0,
            runningAvgDelay: null,
            runningAvgJitter: null,
            runningAvgLoss: null,
            finalAvgDelay: null,
            finalAvgJitter: null,
            finalAvgLoss: null,
            isGood: null, // Based on final avg
            score: null, // Based on final avg
            domElement: pathElement, // Reference to the UI element
             // References to specific output elements within the path's UI
             domOutputs: {
                 finalDelay: pathElement.querySelector('.final-avg-delay'),
                 finalJitter: pathElement.querySelector('.final-avg-jitter'),
                 finalLoss: pathElement.querySelector('.final-avg-loss'),
                 runningDelay: pathElement.querySelector('.running-avg-delay'),
                 runningJitter: pathElement.querySelector('.running-avg-jitter'),
                 runningLoss: pathElement.querySelector('.running-avg-loss'),
                 delayWarning: pathElement.querySelector('.delay-warning'),
                 jitterWarning: pathElement.querySelector('.jitter-warning'),
                 lossWarning: pathElement.querySelector('.loss-warning'),
             },
             // References to input elements for easy access
             domInputs: {
                 name: nameInput,
                 priority: priorityInput,
                 delaySlider: instantDelaySlider,
                 delayInput: instantDelayInput,
                 jitterSlider: instantJitterSlider,
                 jitterInput: instantJitterInput,
                 lossSlider: instantLossSlider,
                 lossInput: instantLossInput
             }
        };

        // Event listeners for the new path's controls
        nameInput.addEventListener('change', () => {
            newPath.name = nameInput.value;
            updatePathVisuals(); // Update label in diagram
            updateCharts(); // Update chart labels
         });
        priorityInput.addEventListener('change', () => { newPath.priority = parseInt(priorityInput.value) || 100; });

        // Link sliders and number inputs
        instantDelaySlider.addEventListener('input', () => { instantDelayInput.value = instantDelaySlider.value; newPath.instantDelay = parseFloat(instantDelaySlider.value); updatePathMetricWarnings(pathId);});
        instantDelayInput.addEventListener('input', () => { instantDelaySlider.value = instantDelayInput.value; newPath.instantDelay = parseFloat(instantDelayInput.value); updatePathMetricWarnings(pathId);});

        instantJitterSlider.addEventListener('input', () => { instantJitterInput.value = instantJitterSlider.value; newPath.instantJitter = parseFloat(instantJitterSlider.value); updatePathMetricWarnings(pathId);});
        instantJitterInput.addEventListener('input', () => { instantJitterSlider.value = instantJitterInput.value; newPath.instantJitter = parseFloat(instantJitterInput.value); updatePathMetricWarnings(pathId);});

        instantLossSlider.addEventListener('input', () => { instantLossInput.value = instantLossSlider.value; newPath.instantLoss = parseFloat(instantLossSlider.value); updatePathMetricWarnings(pathId);});
        instantLossInput.addEventListener('input', () => { instantLossSlider.value = instantLossInput.value; newPath.instantLoss = parseFloat(instantLossInput.value); updatePathMetricWarnings(pathId);});


        deleteButton.addEventListener('click', () => removePath(pathId));

        pathListDiv.appendChild(pathElement);
        paths.push(newPath);
        updatePathCount();
        updatePathVisuals(); // Add the path line to the diagram
        updatePathMetricWarnings(pathId); // Check initial warnings
        updateCharts(); // Add path to charts
    }

    function removePath(pathId) {
        if (simulationState.isRunning && simulationState.activePathId === pathId) {
            alert("Simülasyon çalışırken aktif path silinemez.");
            return;
        }
        const pathIndex = paths.findIndex(p => p.id === pathId);
        if (pathIndex > -1) {
            const pathToRemove = paths[pathIndex];
            // Remove visual element from control panel
            pathToRemove.domElement.remove();
            // Remove network diagram line and label
             const lineElement = networkDiagramDiv.querySelector(`.path-line[data-path-id="${pathId}"]`);
             if (lineElement) lineElement.remove();
             const nameLabel = networkDiagramDiv.querySelector(`.path-name-label[data-path-id="${pathId}"]`);
             if (nameLabel) nameLabel.remove();

            // Remove from internal state
            paths.splice(pathIndex, 1);

             // If the removed path was active, reset active path
            if (simulationState.activePathId === pathId) {
                simulationState.activePathId = null;
                simActivePathSpan.textContent = '-';
                 trafficDot.style.display = 'none';
            }

            updatePathCount();
            updatePathVisuals(); // Re-render remaining paths correctly spaced
            updateCharts(); // Remove path from charts
            logMessage(`Path ${pathToRemove.name} (ID ${pathId}) silindi.`);
        }
    }

    function updatePathCount() {
        pathCountSpan.textContent = paths.length;
        addPathButton.disabled = paths.length >= 8;
    }

    function updatePathMetricWarnings(pathId) {
        const path = paths.find(p => p.id === pathId);
        if (!path || !path.domOutputs) return; // Path or its UI elements might not be fully initialized

        path.domOutputs.delayWarning.style.display = path.instantDelay > slaCriteria.maxDelay ? 'inline-block' : 'none';
        path.domOutputs.jitterWarning.style.display = path.instantJitter > slaCriteria.maxJitter ? 'inline-block' : 'none';
        path.domOutputs.lossWarning.style.display = path.instantLoss > slaCriteria.maxLoss ? 'inline-block' : 'none';
    }

    // --- Simulation Logic ---
    function startSimulation() {
        if (simulationState.isRunning) return;
        if (paths.length === 0) {
            alert("Simülasyonu başlatmak için en az bir path eklemelisiniz.");
            return;
        }

        logMessage("Simülasyon başlatılıyor...");
        simulationState.isRunning = true;
        startButton.disabled = true;
        stopButton.disabled = false;
        resetButton.disabled = true; // Disable reset while running

        // Reset cycle-specific state before starting
        simulationState.currentCycle = 1;
        simulationState.currentPhase = 'DECISION'; // Start with decision phase
        simulationState.currentPacketInCycle = 0;
        paths.forEach(path => { // Clear previous run's final/running values & samples
            path.finalAvgDelay = path.finalAvgJitter = path.finalAvgLoss = null;
            path.runningAvgDelay = path.runningAvgJitter = path.runningAvgLoss = null;
            path.isGood = null;
            path.score = null;
            path.samplesDelay = []; path.samplesJitter = []; path.samplesLoss = [];
            path.currentPacketCount = 0;
        });
        clearCharts(); // Clear chart data visually, keep labels
        updateFinalAverageUI(); // Clear UI display of final avgs
        updateRunningAverageUI(); // Clear UI display of running avgs

        // Ensure durations are calculated with current config
        updateProbeConfig();
        updateSlaConfig(); // Ensure SLA values are current
        updateBehaviorConfig(); // Load speed factor etc.

        simulationState.phaseStartTime = Date.now();
        updateUIStatus(); // Update status display

        // Start the loop
        runSimulationStep();
    }

    function stopSimulation() {
        if (!simulationState.isRunning) return;
        logMessage("Simülasyon durduruluyor...");
        simulationState.isRunning = false;
        clearTimeout(simulationState.globalTimerId);
        simulationState.globalTimerId = null;
        startButton.disabled = false;
        stopButton.disabled = true;
        resetButton.disabled = false;
        updateUIStatus(); // Update status display
        trafficDot.style.display = 'none';
    }

    function resetSimulation() {
         logMessage("Simülasyon sıfırlanıyor...");
         resetSimulationState(true); // Pass true to ensure full reset including defaults
         updateProbeConfig(); // Reload config from potentially changed inputs
         updateSlaConfig();
         updateBehaviorConfig();
         disableConfigInputs(false); // Ensure inputs are enabled
         updateUI(); // Update all UI elements
         logMessage("Varsayılan ayarlara dönüldü.");
    }

    function disableConfigInputs(disable) {
         // Path Management (Add button and individual path inputs/delete buttons)
         addPathButton.disabled = disable || paths.length >= 8;
         paths.forEach(path => {
            if(path.domInputs) { // Check if UI elements exist
                 path.domInputs.name.disabled = disable;
                 path.domInputs.priority.disabled = disable;
                 path.domInputs.delaySlider.disabled = disable;
                 path.domInputs.delayInput.disabled = disable;
                 path.domInputs.jitterSlider.disabled = disable;
                 path.domInputs.jitterInput.disabled = disable;
                 path.domInputs.lossSlider.disabled = disable;
                 path.domInputs.lossInput.disabled = disable;
             }
             if (path.domElement) { // Check if main element exists
                 const deleteBtn = path.domElement.querySelector('.delete-path');
                 if (deleteBtn) deleteBtn.disabled = disable;
             }
         });
         // Scenario buttons
         scenarioGoodMplsButton.disabled = disable;
         scenarioBadMplsButton.disabled = disable;
         scenarioFlappingButton.disabled = disable;
         // Note: All other inputs remain enabled during simulation
    }


    function runSimulationStep() {
        if (!simulationState.isRunning) return;

        const now = Date.now();
        const scaledSpeed = simulationState.simulationSpeedFactor;

        try {
            // --- Update Cycle Progress ---
            updateProgressBar();

            // --- Phase Logic ---
            switch (simulationState.currentPhase) {
                case 'IDLE':
                    // Should not happen if startSimulation is used correctly
                    stopSimulation();
                    return;

                case 'DECISION':
                    updateUIStatus(); // Update phase display
                    simMeasurementStepSpan.textContent = "-";
                    logMessage(`--- Döngü ${simulationState.currentCycle} Başlangıcı ---`);
                    makeRoutingDecision(); // Use final averages from *previous* cycle
                    updateActivePathVisuals(); // Highlight the chosen path for this cycle
                    updatePathStatusVisuals(); // Color paths based on *previous* final averages

                    // Reset for upcoming measurement phase
                     paths.forEach(path => {
                         path.samplesDelay = [];
                         path.samplesJitter = [];
                         path.samplesLoss = [];
                         path.currentPacketCount = 0;
                         path.runningAvgDelay = null;
                         path.runningAvgJitter = null;
                         path.runningAvgLoss = null;
                         // Clear running average UI display for this path
                         updateRunningAverageUIForPath(path);
                     });
                     clearCharts(); // Clear visual data in charts, keep labels
                    simulationState.currentPacketInCycle = 0;

                     // Transition to Measurement Phase
                    simulationState.currentPhase = 'MEASUREMENT';
                    simulationState.phaseStartTime = now;
                    updateUIStatus();
                    // console.log("Transitioning to MEASUREMENT");
                    // The first "packet" is sent/measured immediately (t=0 of measurement phase)
                     scheduleNextStep(1); // Schedule the first measurement step almost immediately
                    break;

                case 'MEASUREMENT':
                    updateUIStatus(); // Update phase display

                    // Increment packet count *before* processing, as packet 1 is the first measurement
                    simulationState.currentPacketInCycle++;

                    // Perform measurement (sample instant values, update running avg)
                    sampleAndCalculateRunningAverages();
                    updateRunningAverageUI(); // Update text display of running averages
                    updateCharts(); // *** CORRECTION: Changed from updateGraphs to updateCharts ***

                    simMeasurementStepSpan.textContent = `${simulationState.currentPacketInCycle} / ${probeConfig.count}`;

                    // Check if measurement phase is complete
                    if (simulationState.currentPacketInCycle >= probeConfig.count) {
                        // Measurement complete, finalize averages
                        finalizeAverages();
                        updateFinalAverageUI(); // Update text display of final averages
                        logMessage(`Döngü ${simulationState.currentCycle}: Ölçüm tamamlandı. Nihai ortalamalar hesaplandı.`);

                         // Transition to Wait Phase
                        simulationState.currentPhase = 'WAIT';
                        simulationState.phaseStartTime = now;
                        simMeasurementStepSpan.textContent = "-"; // Reset step counter for wait phase
                        updateUIStatus();
                        // console.log("Transitioning to WAIT");
                         const waitDurationMs = simulationState.waitPhaseDuration * 1000 / scaledSpeed;
                        scheduleNextStep(waitDurationMs > 1 ? waitDurationMs : 1); // Schedule end of wait phase
                    } else {
                        // Schedule next measurement packet
                        const waitBetweenPacketsMs = probeConfig.wait * 1000 / scaledSpeed;
                         scheduleNextStep(waitBetweenPacketsMs > 1 ? waitBetweenPacketsMs : 1); // Schedule next packet
                    }
                    break;

                case 'WAIT':
                    updateUIStatus(); // Update phase display
                    // Wait phase is complete, start next cycle
                    simulationState.currentCycle++;
                    simulationState.currentPhase = 'DECISION';
                    simulationState.phaseStartTime = now;
                    // console.log("Transitioning to DECISION for next cycle");
                    updateUIStatus(); // Update cycle number
                    scheduleNextStep(1); // Schedule decision phase almost immediately
                    break;
            }
        } catch (error) {
            console.error("Simulation step error:", error);
            logMessage(`HATA: Simülasyon adımında hata oluştu: ${error.message}`);
            stopSimulation();
        }
    }

     function scheduleNextStep(delayMs) {
         // Clear previous timer if any exists
         if (simulationState.globalTimerId) {
             clearTimeout(simulationState.globalTimerId);
         }
         // Clamp delay to a minimum positive value to prevent issues
         const effectiveDelay = Math.max(1, delayMs);
         // Set new timer
         simulationState.globalTimerId = setTimeout(runSimulationStep, effectiveDelay);
     }


    function sampleAndCalculateRunningAverages() {
        // console.log(`Sampling packet ${simulationState.currentPacketInCycle}`);
        paths.forEach(path => {
            // Sample instantaneous values (these are user-controlled sliders)
            const currentDelay = path.instantDelay;
            const currentJitter = path.instantJitter;
            const currentLoss = path.instantLoss;

            path.samplesDelay.push(currentDelay);
            path.samplesJitter.push(currentJitter);
            path.samplesLoss.push(currentLoss);
            path.currentPacketCount++;

            // Calculate running average
            path.runningAvgDelay = path.samplesDelay.reduce((a, b) => a + b, 0) / path.currentPacketCount;
            path.runningAvgJitter = path.samplesJitter.reduce((a, b) => a + b, 0) / path.currentPacketCount;
            path.runningAvgLoss = path.samplesLoss.reduce((a, b) => a + b, 0) / path.currentPacketCount;

            // console.log(`Path ${path.name} (${path.id}) Running Avg after packet ${path.currentPacketCount}: D=${path.runningAvgDelay.toFixed(1)}, J=${path.runningAvgJitter.toFixed(1)}, L=${path.runningAvgLoss.toFixed(2)}%`);
        });
    }

     function finalizeAverages() {
         paths.forEach(path => {
             // The last running average becomes the final average for this cycle
             path.finalAvgDelay = path.runningAvgDelay;
             path.finalAvgJitter = path.runningAvgJitter;
             path.finalAvgLoss = path.runningAvgLoss;

             // Calculate isGood and Score based on these *final* averages for the *next* decision
             // Ensure values are numbers before comparison
             const finalDelay = path.finalAvgDelay ?? Infinity;
             const finalJitter = path.finalAvgJitter ?? Infinity;
             const finalLoss = path.finalAvgLoss ?? Infinity;

             path.isGood = finalDelay <= slaCriteria.maxDelay &&
                           finalJitter <= slaCriteria.maxJitter &&
                           finalLoss <= slaCriteria.maxLoss;

             if (!path.isGood) {
                 // Calculate score based on FR4.2 formula
                 path.score = (finalDelay * 0.9) +
                              (Math.max(0, finalJitter - slaCriteria.maxJitter) * 35.0) +
                              (finalLoss * 100.0); // Loss is 0-100, so multiply directly
             } else {
                 path.score = 0; // Good paths have a score of 0 for simplicity
             }
             // console.log(`Path ${path.name} (${path.id}) Final Avg: D=${path.finalAvgDelay?.toFixed(1)}, J=${path.finalAvgJitter?.toFixed(1)}, L=${path.finalAvgLoss?.toFixed(2)}%, isGood=${path.isGood}, Score=${path.score?.toFixed(2)}`);
         });
     }

    function makeRoutingDecision() {
        logMessage(`Döngü ${simulationState.currentCycle}: Yönlendirme kararı veriliyor (Önceki döngünün Nihai Ortalamalarına göre)...`);

        if (paths.length === 0) {
            logMessage(" Aktif path yok (Path bulunamadı).");
            simulationState.activePathId = null;
            simActivePathSpan.textContent = '-'; // Update UI directly here
            return;
        }

        // Check if we have valid final averages from a previous cycle (isGood is calculated in finalizeAverages)
        const hasPreviousAverages = paths.some(p => p.isGood !== null);

        if (!hasPreviousAverages && simulationState.currentCycle === 1) {
            // First cycle, no metrics yet. Default to highest priority (lowest number).
            paths.sort((a, b) => a.priority - b.priority);
            simulationState.activePathId = paths[0].id;
            logMessage(` İlk döngü, metrik yok. Önceliğe göre varsayılan path seçildi: ${paths[0].name} (ID: ${paths[0].id})`);
            simActivePathSpan.textContent = paths[0].name; // Update UI
            return; // Decision made for cycle 1
        }

        // Proceed with logic using previous cycle's final averages and calculated isGood/score

        // Sort paths primarily by priority (ascending) for selection logic tie-breaking
        const sortedPaths = [...paths].sort((a, b) => a.priority - b.priority);

        let currentActivePath = paths.find(p => p.id === simulationState.activePathId);
        let bestPath = null;

        // Log current state before decision
        sortedPaths.forEach(p => {
            logMessage(` - Path ${p.name} (Pri: ${p.priority}): Nihai Ort [Gec: ${p.finalAvgDelay?.toFixed(1) ?? 'N/A'}, Jit: ${p.finalAvgJitter?.toFixed(1) ?? 'N/A'}, Kay: ${p.finalAvgLoss?.toFixed(2) ?? 'N/A'}%], SLA Uygun: ${p.isGood === null ? 'N/A' : p.isGood}, Skor: ${p.score === null ? '-' : p.score.toFixed(2)}`);
        });
        logMessage(` Mevcut Aktif Path: ${currentActivePath ? currentActivePath.name : 'Yok'} (ID: ${simulationState.activePathId ?? 'Yok'})`);
        logMessage(` Preemptive Mod: ${simulationState.preemptiveMode ? 'Aktif' : 'Pasif'}`);


        // --- Selection Logic (FR4.3 based on final averages from previous cycle) ---
        const goodPaths = sortedPaths.filter(p => p.isGood === true); // Explicitly check true
        const badPaths = sortedPaths.filter(p => p.isGood === false); // Explicitly check false

        if (simulationState.preemptiveMode) {
            // Preemptive Mode: Always seek the highest priority *good* path.
             if (goodPaths.length > 0) {
                 bestPath = goodPaths[0]; // Highest priority good path (due to sorting)
                 logMessage(" Preemptive: En öncelikli SLA uyumlu path'e bakılıyor.");
             } else {
                 // No good paths, choose the best of the bad ones (lowest score, then priority)
                 badPaths.sort((a, b) => {
                     if (a.score !== b.score) {
                         return a.score - b.score; // Lower score is better
                     }
                     return a.priority - b.priority; // Tie-break with priority
                 });
                 bestPath = badPaths.length > 0 ? badPaths[0] : null; // Handle case where all paths might be 'null' status initially?
                 logMessage(" Preemptive: SLA uyumlu path yok. En düşük skorlu/öncelikli path'e bakılıyor.");
             }
        } else {
            // Non-Preemptive Mode: Stick with current if it's good.
            if (currentActivePath && currentActivePath.isGood === true) {
                bestPath = currentActivePath;
                 logMessage(" Non-Preemptive: Mevcut path SLA uyumlu, path değiştirilmedi.");
            } else {
                // Current path is bad, doesn't exist, or status is null. Find the best alternative.
                 if (goodPaths.length > 0) {
                     bestPath = goodPaths[0]; // Highest priority good path
                     logMessage(` Non-Preemptive: Mevcut path (${currentActivePath?.name ?? 'Yok'}) SLA uyumlu değil veya yok. En öncelikli SLA uyumlu path'e bakılıyor.`);
                 } else {
                     // No good paths, choose the best of the bad ones (lowest score, then priority)
                     badPaths.sort((a, b) => {
                         if (a.score !== b.score) {
                             return a.score - b.score;
                         }
                         return a.priority - b.priority;
                     });
                    bestPath = badPaths.length > 0 ? badPaths[0] : null;
                    logMessage(" Non-Preemptive: SLA uyumlu path yok. En düşük skorlu/öncelikli path'e bakılıyor.");
                 }
            }
        }

        // --- Set Active Path ---
        // Handle the very rare case where no path could be selected (e.g., all paths had null status and no good/bad paths found)
        if (!bestPath && sortedPaths.length > 0) {
            bestPath = sortedPaths[0]; // Fallback to highest priority overall if logic failed
            logMessage(` UYARI: Normal seçim mantığı path bulamadı. En öncelikli path (${bestPath.name}) seçildi.`);
        }


        if (bestPath) {
            if (simulationState.activePathId !== bestPath.id) {
                 logMessage(` KARAR: Aktif path ${bestPath.name} (ID: ${bestPath.id}) olarak değiştirildi.`);
                simulationState.activePathId = bestPath.id;
            } else {
                 logMessage(` KARAR: Aktif path değişmedi: ${bestPath.name} (ID: ${bestPath.id}).`);
            }
        } else {
             logMessage(" KARAR: Aktif path belirlenemedi (Path yok?).");
            simulationState.activePathId = null;
        }
         simActivePathSpan.textContent = bestPath?.name ?? '-'; // Update UI
    }


    // --- UI Updates ---
    function updateUI() {
        // Update status texts
        updateUIStatus();

        // Update Path UI elements (Final & Running Averages display in control panel)
         updateFinalAverageUI();
         updateRunningAverageUI();

         // Update Path Visuals (Lines in diagram, status colors, active highlight)
         updatePathVisuals(); // Redraw lines and labels

         // Update Graphs (called dynamically during measurement, but ensure structure is correct)
         updateCharts(); // Make sure chart labels/structure match current paths
    }

    function updateUIStatus() {
        simStatusSpan.textContent = simulationState.isRunning ? "Çalışıyor" : (simulationState.currentPhase === 'IDLE' ? "Bekliyor" : "Durduruldu");
        simCycleSpan.textContent = simulationState.currentCycle;
        let phaseText = simulationState.currentPhase;
        if (phaseText === 'IDLE') phaseText = '-';
        if (phaseText === 'MEASUREMENT') phaseText = 'Ölçüm';
        if (phaseText === 'WAIT') phaseText = 'Bekleme';
        if (phaseText === 'DECISION') phaseText = 'Karar';
        simPhaseSpan.textContent = phaseText;
        simActivePathSpan.textContent = paths.find(p => p.id === simulationState.activePathId)?.name || '-';
        // Measurement step is updated within the measurement phase logic
    }

     function updateFinalAverageUI() {
         paths.forEach(path => updateFinalAverageUIForPath(path));
     }
     function updateFinalAverageUIForPath(path) {
         if (!path || !path.domOutputs) return;
         path.domOutputs.finalDelay.textContent = path.finalAvgDelay?.toFixed(1) ?? '-';
         path.domOutputs.finalJitter.textContent = path.finalAvgJitter?.toFixed(1) ?? '-';
         path.domOutputs.finalLoss.textContent = path.finalAvgLoss?.toFixed(2) ?? '-';
     }

     function updateRunningAverageUI() {
         paths.forEach(path => updateRunningAverageUIForPath(path));
     }
     function updateRunningAverageUIForPath(path) {
         if (!path || !path.domOutputs) return;
         path.domOutputs.runningDelay.textContent = path.runningAvgDelay?.toFixed(1) ?? '-';
         path.domOutputs.runningJitter.textContent = path.runningAvgJitter?.toFixed(1) ?? '-';
         path.domOutputs.runningLoss.textContent = path.runningAvgLoss?.toFixed(2) ?? '-';
     }

    function updatePathVisuals() {
        // Ensure the container exists
        if (!networkDiagramDiv) return;

        // Remove existing lines and labels first to avoid duplicates/orphans
        networkDiagramDiv.querySelectorAll('.path-line, .path-name-label').forEach(el => el.remove());

        const totalPaths = paths.length;
        // Calculate vertical spacing based on the container's available height for lines
        // Use percentages relative to the diagram's padding area
        const availableHeightPercent = 100 - 20; // e.g., 10% padding top & bottom = 80% available
        const verticalSpacing = totalPaths > 1 ? availableHeightPercent / (totalPaths -1) : availableHeightPercent / 2; // Center if only 1 path
        const startTopPercent = 10; // Start 10% from the top padding edge


        paths.forEach((path, index) => {
            const pathLine = document.createElement('div');
            pathLine.classList.add('path-line');
            pathLine.dataset.pathId = path.id;

            // Distribute paths vertically within the available space
            let topPosition = startTopPercent + (index * verticalSpacing);
             if (totalPaths === 1) topPosition = 50; // Center single path

             // Apply dynamic top position - ensuring it's within bounds might be needed for many paths
             pathLine.style.top = `${topPosition}%`;


            const pathLabel = document.createElement('span');
            pathLabel.classList.add('path-name-label');
            pathLabel.textContent = path.name;
            pathLabel.dataset.pathId = path.id;
            // Position label relative to line's vertical position, centered horizontally
            pathLabel.style.top = `calc(${pathLine.style.top} - 10px)`; // Adjust vertical offset as needed
            pathLabel.style.left = '50%'; // Center horizontally over the line's midpoint
            pathLabel.style.transform = 'translateX(-50%)'; // CSS horizontal centering trick

            // Append line first, then label
            networkDiagramDiv.appendChild(pathLine);
            networkDiagramDiv.appendChild(pathLabel);
        });

         // Re-apply status and active classes after recreating elements
         updatePathStatusVisuals();
         updateActivePathVisuals();
    }

    function updatePathStatusVisuals() {
        // Colors path lines based on the 'isGood' status derived from *Final* Averages (used for the routing decision)
        paths.forEach(path => {
            const lineElement = networkDiagramDiv.querySelector(`.path-line[data-path-id="${path.id}"]`);
            if (lineElement) {
                lineElement.classList.remove('good', 'bad');
                // Only apply color if status is definitively known
                if (path.isGood === true) {
                    lineElement.classList.add('good');
                } else if (path.isGood === false) {
                    lineElement.classList.add('bad');
                }
                // If isGood is null (e.g., before first calculation), it remains default color
            }
        });
    }

    function updateActivePathVisuals() {
        // Remove active class from all lines first
        networkDiagramDiv.querySelectorAll('.path-line').forEach(line => line.classList.remove('active'));

        // Add active class to the current active path
        const activePathId = simulationState.activePathId;
        if (activePathId !== null) {
            const activeLine = networkDiagramDiv.querySelector(`.path-line[data-path-id="${activePathId}"]`);
            if (activeLine) {
                activeLine.classList.add('active');
                 // Show and position traffic dot on the active line
                 trafficDot.style.top = activeLine.style.top; // Align vertically with the center of the line
                 trafficDot.style.display = simulationState.isRunning ? 'block' : 'none'; // Show only if running
            } else {
                 trafficDot.style.display = 'none'; // Hide if active path line not found (shouldn't happen ideally)
            }
        } else {
             trafficDot.style.display = 'none'; // Hide if no active path
        }
    }


    function updateProgressBar() {
        if (!simulationState.isRunning || simulationState.cycleDuration <= 0) {
            progressBar.style.width = '0%';
            return;
        }

        const now = Date.now();
        let elapsedTimeInPhase = (now - simulationState.phaseStartTime) / 1000 * simulationState.simulationSpeedFactor; // Account for speed, in seconds
        let cycleProgressPercent = 0; // Progress as a percentage (0-100)

        // Calculate theoretical durations in seconds (already done in calculateDurations)
        const measureDuration = simulationState.measurementPhaseDuration;
        const waitDuration = simulationState.waitPhaseDuration;
        const totalDuration = simulationState.cycleDuration;

        if (simulationState.currentPhase === 'MEASUREMENT') {
            // Calculate progress based on current packet number and total packets
            const packetProgress = simulationState.currentPacketInCycle / probeConfig.count;
            cycleProgressPercent = packetProgress * 100;
        } else if (simulationState.currentPhase === 'WAIT') {
            // During wait phase, progress is 100% (measurement complete)
            cycleProgressPercent = 100;
        } else if (simulationState.currentPhase === 'DECISION') {
            // Decision is quick, show 0 progress for the new cycle starting
            cycleProgressPercent = 0;
        }

        progressBar.style.width = `${Math.min(100, Math.max(0, cycleProgressPercent))}%`;
    }


    function logMessage(message) {
        const timestamp = new Date().toLocaleTimeString();
        // Sanitize message slightly to prevent accidental HTML injection if needed
        const sanitizedMessage = message.replace(/</g, "<").replace(/>/g, ">");
        decisionLogDiv.innerHTML += `[${timestamp}] ${sanitizedMessage}\n`;
        decisionLogDiv.scrollTop = decisionLogDiv.scrollHeight; // Auto-scroll
    }

    // --- Charting ---
    function initCharts() {
        // Register the annotation plugin
        if (typeof ChartAnnotation !== 'undefined') {
            Chart.register(ChartAnnotation);
        } else if (typeof chartjsPluginAnnotation !== 'undefined') {
            Chart.register(chartjsPluginAnnotation);
        } else {
            console.warn("Chart.js annotation plugin not found. Charts will be displayed without annotations.");
        }

        const ctxDelay = document.getElementById('delay-chart').getContext('2d');
        const ctxJitter = document.getElementById('jitter-chart').getContext('2d');
        const ctxLoss = document.getElementById('loss-chart').getContext('2d');

        const createChartOptions = (metricName, unit, slaValue) => ({
            type: 'bar',
            data: {
                labels: [], // Path names will be populated
                datasets: [{
                    label: `Çalışan Ort. ${metricName} (${unit})`,
                    data: [], // Running averages
                    backgroundColor: [], // Will be updated based on SLA
                    borderColor: [],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                 plugins: {
                    title: { display: true, text: `${metricName} vs SLA Kriteri` },
                    legend: { display: false }, // Hide legend for single dataset
                    tooltip: { // Customize tooltips if needed
                         callbacks: {
                             label: function(context) {
                                 let label = context.dataset.label || '';
                                 if (label) {
                                     label += ': ';
                                 }
                                 if (context.parsed.y !== null) {
                                     label += context.parsed.y.toFixed(unit === '%' ? 2 : 1) + unit;
                                 }
                                 return label;
                             }
                         }
                    },
                    annotation: { // Configuration for chartjs-plugin-annotation
                         annotations: {
                             slaLine: {
                                 type: 'line',
                                 scaleID: 'y', // Explicitly link to the y-axis
                                 value: slaValue, // The threshold value
                                 borderColor: 'rgb(255, 99, 132)',
                                 borderWidth: 2,
                                 borderDash: [6, 6],
                                 label: {
                                     content: `SLA: ${slaValue}${unit}`,
                                     enabled: true,
                                     position: 'end', // 'start', 'center', 'end'
                                     backgroundColor: 'rgba(255, 99, 132, 0.8)',
                                     color: 'white',
                                     font: {
                                        size: 10
                                     },
                                     yAdjust: -10 // Adjust label position slightly above line
                                 }
                             }
                         }
                     }
                 },
                scales: {
                    y: {
                        beginAtZero: true,
                         // Dynamically adjust max based on data and SLA line
                         // suggestedMax: slaValue * 1.5
                         afterDataLimits: (scale) => {
                             // Ensure the SLA line is always visible
                             scale.max = Math.max(scale.max * 1.1, slaValue * 1.2);
                         }
                    }
                },
                 animation: {
                     duration: 150 // Slightly faster animation for real-time feel
                 }
            }
        });

         // Destroy previous charts if they exist (e.g., on reset)
         if (charts.delay) charts.delay.destroy();
         if (charts.jitter) charts.jitter.destroy();
         if (charts.loss) charts.loss.destroy();

        charts.delay = new Chart(ctxDelay, createChartOptions('Gecikme', 'ms', slaCriteria.maxDelay));
        charts.jitter = new Chart(ctxJitter, createChartOptions('Jitter', 'ms', slaCriteria.maxJitter));
        charts.loss = new Chart(ctxLoss, createChartOptions('Kayıp', '%', slaCriteria.maxLoss));

        // Initial population of chart labels based on current paths
         updateCharts(); // Called to set initial labels and empty data
    }

    // Call this when SLA criteria change to update the lines on the charts
     function updateChartSLALines() {
        if (!charts.delay || !charts.jitter || !charts.loss) return;

         const updateLine = (chart, newValue, unit) => {
            if (chart.options.plugins.annotation) {
                 chart.options.plugins.annotation.annotations.slaLine.value = newValue;
                 chart.options.plugins.annotation.annotations.slaLine.label.content = `SLA: ${newValue}${unit}`;
                 // Optional: Adjust y-axis max based on new SLA value
                 chart.options.scales.y.afterDataLimits = (scale) => {
                     scale.max = Math.max(scale.max * 1.1, newValue * 1.2);
                 };
                 chart.update(); // Redraw chart with updated annotation
             }
         };

         updateLine(charts.delay, slaCriteria.maxDelay, 'ms');
         updateLine(charts.jitter, slaCriteria.maxJitter, 'ms');
         updateLine(charts.loss, slaCriteria.maxLoss, '%');
     }


     function updateCharts() {
         if (!charts.delay || !charts.jitter || !charts.loss || !Chart.getChart(charts.delay.canvas)) {
             // console.warn("Charts not ready for update.");
             return; // Charts not initialized or already destroyed
         }

         const pathNames = paths.map(p => p.name);
         const runningDelays = paths.map(p => p.runningAvgDelay);
         const runningJitters = paths.map(p => p.runningAvgJitter);
         const runningLosses = paths.map(p => p.runningAvgLoss);

         // Determine bar colors based on running average vs SLA
         const delayColors = runningDelays.map(val => (val !== null && val > slaCriteria.maxDelay) ? 'rgba(220, 53, 69, 0.7)' : 'rgba(40, 167, 69, 0.7)'); // Red if > SLA, else Green
         const jitterColors = runningJitters.map(val => (val !== null && val > slaCriteria.maxJitter) ? 'rgba(220, 53, 69, 0.7)' : 'rgba(40, 167, 69, 0.7)');
         const lossColors = runningLosses.map(val => (val !== null && val > slaCriteria.maxLoss) ? 'rgba(220, 53, 69, 0.7)' : 'rgba(40, 167, 69, 0.7)');

         // Update Delay Chart
         charts.delay.data.labels = pathNames;
         charts.delay.data.datasets[0].data = runningDelays;
         charts.delay.data.datasets[0].backgroundColor = delayColors;
         charts.delay.data.datasets[0].borderColor = delayColors.map(c => c.replace('0.7', '1')); // Solid border
         // No need to update annotation value here, it's handled by updateChartSLALines

         // Update Jitter Chart
         charts.jitter.data.labels = pathNames;
         charts.jitter.data.datasets[0].data = runningJitters;
         charts.jitter.data.datasets[0].backgroundColor = jitterColors;
         charts.jitter.data.datasets[0].borderColor = jitterColors.map(c => c.replace('0.7', '1'));

         // Update Loss Chart
         charts.loss.data.labels = pathNames;
         charts.loss.data.datasets[0].data = runningLosses;
         charts.loss.data.datasets[0].backgroundColor = lossColors;
         charts.loss.data.datasets[0].borderColor = lossColors.map(c => c.replace('0.7', '1'));

         // Update all charts
         charts.delay.update();
         charts.jitter.update();
         charts.loss.update();
     }

     function clearCharts() {
         if (!charts.delay || !charts.jitter || !charts.loss) return;

         const updateEmpty = (chart) => {
             if (chart && Chart.getChart(chart.canvas)) { // Check if chart instance exists
                 chart.data.labels = paths.map(p => p.name); // Keep/update labels
                 chart.data.datasets[0].data = paths.map(() => null); // Set data to null
                 // Use a neutral color when data is cleared
                 const neutralColor = 'rgba(201, 203, 207, 0.5)'; // Light grey
                 chart.data.datasets[0].backgroundColor = paths.map(() => neutralColor);
                 chart.data.datasets[0].borderColor = paths.map(() => neutralColor.replace('0.5', '1'));
                 chart.update();
             }
         };

         updateEmpty(charts.delay);
         updateEmpty(charts.jitter);
         updateEmpty(charts.loss);
     }

    // --- Scenarios ---
    function loadScenario(scenarioData) {
         if (simulationState.isRunning) {
             alert("Senaryo yüklemek için önce simülasyonu durdurun.");
             return;
         }
         logMessage(`Senaryo yükleniyor: ${scenarioData.name}`);
         // Perform a full reset before loading to ensure clean state
         resetSimulationState(true);

         // Load SLA Criteria
         slaDelayInput.value = scenarioData.sla.delay;
         slaJitterInput.value = scenarioData.sla.jitter;
         slaLossInput.value = scenarioData.sla.loss;
         updateSlaConfig(); // Apply SLA values and update warnings/chart lines

         // Load Probe Config (optional, if provided in scenario)
         if (scenarioData.probe) {
             probeCountInput.value = scenarioData.probe.count;
             probeWaitInput.value = scenarioData.probe.wait;
             probeIntervalInput.value = scenarioData.probe.interval;
             updateProbeConfig(); // Apply probe settings and recalculate durations
         }

          // Load Behavior (optional)
          if (scenarioData.behavior) {
              preemptiveModeCheckbox.checked = scenarioData.behavior.preemptive;
              updateBehaviorConfig(); // Apply behavior settings
          }

         // Clear default paths added by reset and add scenario paths
         pathListDiv.innerHTML = ''; // Clear UI representation first
         paths = []; // Clear internal array
         nextPathId = 0; // Reset ID counter
         scenarioData.paths.forEach(p => {
             // Add path using the function which handles UI, internal state, charts etc.
             addPath(p.name, p.priority, p.instantDelay, p.instantJitter, p.instantLoss);
         });

         // No need to call updateUI() explicitly here, as individual update functions
         // (updateSlaConfig, updateProbeConfig, addPath) handle necessary UI updates.
         // Maybe call updatePathVisuals one last time to be sure.
         updatePathVisuals();
         logMessage(`Senaryo "${scenarioData.name}" yüklendi.`);
     }

    // Predefined Scenarios
     const scenarios = {
         goodMpls: {
             name: "İyi MPLS",
             sla: { delay: 150, jitter: 30, loss: 1 },
             probe: { count: 10, wait: 1, interval: 5 }, // Default probe settings
             behavior: { preemptive: false }, // Default behavior
             paths: [
                 { name: "MPLS", priority: 100, instantDelay: 20, instantJitter: 5, instantLoss: 0 },
                 { name: "Internet", priority: 200, instantDelay: 60, instantJitter: 25, instantLoss: 0.8 }
             ]
         },
         badMpls: {
             name: "Kötü MPLS",
             sla: { delay: 150, jitter: 30, loss: 1 },
             probe: { count: 10, wait: 1, interval: 5 },
             behavior: { preemptive: false },
             paths: [
                 { name: "MPLS", priority: 100, instantDelay: 180, instantJitter: 40, instantLoss: 2 },
                 { name: "Internet", priority: 200, instantDelay: 60, instantJitter: 25, instantLoss: 0.8 }
             ]
         },
         flappingInternet: {
              name: "Değişken İnternet",
              sla: { delay: 100, jitter: 20, loss: 0.5 }, // Stricter SLA
              probe: { count: 5, wait: 0.5, interval: 2 }, // Faster probing
              behavior: { preemptive: true }, // Preemptive mode
              paths: [
                  { name: "MPLS", priority: 100, instantDelay: 30, instantJitter: 5, instantLoss: 0 },
                  // Internet path starts good, user can manually make it flap during sim by adjusting sliders
                  { name: "Internet", priority: 200, instantDelay: 50, instantJitter: 15, instantLoss: 0.2 }
              ]
          }
     };


    // --- Event Listeners Setup ---
    function setupEventListeners() {
        // Simulation Controls
        startButton.addEventListener('click', startSimulation);
        stopButton.addEventListener('click', stopSimulation);
        resetButton.addEventListener('click', () => resetSimulation(true)); // Ensure full reset on button click

        // Configuration Inputs
        probeCountInput.addEventListener('change', updateProbeConfig);
        probeWaitInput.addEventListener('change', updateProbeConfig);
        probeIntervalInput.addEventListener('change', updateProbeConfig);
        slaDelayInput.addEventListener('change', updateSlaConfig);
        slaJitterInput.addEventListener('change', updateSlaConfig);
        slaLossInput.addEventListener('change', updateSlaConfig);
        preemptiveModeCheckbox.addEventListener('change', updateBehaviorConfig);
        simulationSpeedSlider.addEventListener('input', updateBehaviorConfig);

        // Path Management
        addPathButton.addEventListener('click', () => addPath()); // Add with default values

        // Scenarios
        scenarioGoodMplsButton.addEventListener('click', () => loadScenario(scenarios.goodMpls));
        scenarioBadMplsButton.addEventListener('click', () => loadScenario(scenarios.badMpls));
        scenarioFlappingButton.addEventListener('click', () => loadScenario(scenarios.flappingInternet));

        // Note: Event listeners for individual path controls are added within the addPath function.
    }

    // --- Start the application ---
    initialize();
});
</script>

</body>
</html>